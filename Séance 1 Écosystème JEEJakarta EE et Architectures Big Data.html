<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S√©ance 1: √âcosyst√®me JEE/Jakarta EE et Architectures Big Data - EXTR√äMEMENT D√âTAILL√âE</title>
    <link href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* General Body and Container Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            color: #333;
            background: linear-gradient(135deg, #e0f2f7 0%, #c8e6c9 100%); /* Light, fresh gradient */
            min-height: 100vh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .container {
            max-width: 1200px;
            margin: 30px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1);
        }

        /* Header and Title Styling */
        .header-section {
            background: linear-gradient(45deg, #2c3e50, #34495e); /* Darker gradient for header */
            color: white;
            padding: 40px 30px;
            border-radius: 15px;
            margin-bottom: 40px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .header-section h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .header-section p {
            font-size: 1.3em;
            font-weight: 300;
            opacity: 0.9;
        }

        .header-section nav {
            margin-top: 20px;
        }

        .header-section nav ul {
            list-style: none;
            padding: 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        .header-section nav ul li {
            margin: 0 15px;
            padding-left: 0; /* Override default list style */
        }

        .header-section nav ul li::before {
            content: none; /* Remove default bullet */
        }

        .header-section nav ul li a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1em;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        .header-section nav ul li a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Section and Subsection Styling */
        section {
            margin-bottom: 40px;
            padding: 25px;
            background: #ffffff;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            border-left: 8px solid #3498db; /* Accent color for sections */
        }

        section h2 {
            font-size: 2.2em;
            color: #2c3e50;
            margin-bottom: 25px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
            font-weight: 600;
        }

        section h3 {
            font-size: 1.8em;
            color: #2980b9;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            font-weight: 600;
        }

        section h4 {
            font-size: 1.4em;
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        /* Paragraph and List Styling */
        p {
            margin-bottom: 15px;
            font-size: 1.05em;
            color: #444;
        }

        ul {
            list-style: none;
            padding-left: 0;
            margin-bottom: 15px;
        }

        ul li {
            position: relative;
            padding-left: 25px;
            margin-bottom: 8px;
            font-size: 1.05em;
            color: #444;
        }

        ul li::before {
            content: '‚Ä¢'; /* Bullet point */
            color: #3498db;
            position: absolute;
            left: 0;
            font-weight: bold;
            font-size: 1.2em;
            line-height: 1;
        }

        /* Specific List Styles for better readability */
        .quiz-questions ol, .tp-steps ol {
            list-style: decimal;
            padding-left: 30px;
        }
        .quiz-questions ol li, .tp-steps ol li {
            padding-left: 0;
            margin-bottom: 15px;
        }
        .quiz-questions ol li::before, .tp-steps ol li::before {
            content: none;
        }
        .quiz-questions ul {
            list-style: none;
            padding: 0;
        }
        .quiz-questions ul li {
            padding-left: 0; /* Reset padding for quiz options */
            margin-bottom: 5px;
        }
        .quiz-questions ul li::before {
            content: none; /* Remove default bullet */
        }
        .quiz-questions input[type="radio"] {
            margin-right: 8px;
        }
        .quiz-questions .feedback {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 5px;
            font-weight: bold;
            display: none; /* Hidden by default */
        }
        .quiz-questions .feedback.correct {
            background-color: #e6ffe6;
            color: #228b22;
        }
        .quiz-questions .feedback.incorrect {
            background-color: #ffe0e0;
            color: #c0392b;
        }
        .quiz-questions .correct-answer {
            font-weight: bold;
            color: #228b22;
            margin-top: 5px;
            display: none; /* Hidden by default */
        }
        .quiz-questions button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
        }
        .quiz-questions button:hover {
            background-color: #2980b9;
        }


        /* Code Blocks */
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        code {
            background-color: #e0e0e0;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #c0392b;
        }

        /* Callout Boxes / Info Boxes */
        .info-box, .warning-box, .tip-box {
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            font-size: 1.05em;
            line-height: 1.6;
            display: flex;
            align-items: flex-start;
        }

        .info-box {
            background-color: #e7f3ff;
            border-left: 5px solid #3498db;
            color: #2c3e50;
        }
        .info-box::before {
            content: 'üí°';
            font-size: 1.8em;
            margin-right: 15px;
            line-height: 1;
        }

        .warning-box {
            background-color: #ffe0e0;
            border-left: 5px solid #e74c3c;
            color: #c0392b;
        }
        .warning-box::before {
            content: '‚ö†Ô∏è';
            font-size: 1.8em;
            margin-right: 15px;
            line-height: 1;
        }

        .tip-box {
            background-color: #e6ffe6;
            border-left: 5px solid #27ae60;
            color: #228b22;
        }
        .tip-box::before {
            content: '‚úÖ';
            font-size: 1.8em;
            margin-right: 15px;
            line-height: 1;
        }

        /* Specific TP Styling */
        .tp-section {
            background: #f8f9fa;
            border-left: 8px solid #28a745; /* Green accent for TP */
        }
        .tp-section h2 {
            border-bottom-color: #28a745;
            color: #28a745;
        }
        .tp-section h3 {
            color: #218838;
        }
        .tp-section h4 {
            color: #1e7e34;
        }

        .tp-step {
            background: #ffffff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            border-left: 5px solid #6c757d;
        }
        .tp-step h4 {
            color: #6c757d;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .tp-step ol {
            list-style: decimal;
            padding-left: 25px;
        }
        .tp-step ol li {
            margin-bottom: 10px;
            padding-left: 5px;
        }
        .tp-step ol li::before {
            content: none;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 30px;
            margin-top: 40px;
            color: #777;
            font-size: 0.9em;
            border-top: 1px solid #eee;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                margin: 15px auto;
                padding: 15px;
            }
            .header-section {
                padding: 25px 15px;
            }
            .header-section h1 {
                font-size: 2em;
            }
            .header-section p {
                font-size: 1em;
            }
            section {
                padding: 15px;
                margin-bottom: 25px;
            }
            section h2 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            section h3 {
                font-size: 1.5em;
                margin-top: 20px;
            }
            section h4 {
                font-size: 1.2em;
                margin-top: 15px;
            }
            p, ul li {
                font-size: 0.95em;
            }
            .info-box, .warning-box, .tip-box {
                font-size: 0.95em;
                padding: 15px;
            }
            .info-box::before, .warning-box::before, .tip-box::before {
                font-size: 1.5em;
                margin-right: 10px;
            }
            .header-section nav ul {
                flex-direction: column;
            }
            .header-section nav ul li {
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-section">
            <h1>üöÄ S√©ance 1: √âcosyst√®me JEE/Jakarta EE et Architectures Big Data</h1>
            <p>Module : Java JEE pour Ing√©nierie Big Data (3√®me Ann√©e Cybers√©curit√©)</p>
            <p>Dur√©e : 4 heures</p>
            <nav>
                <ul>
                    <li><a href="#objectifs">Objectifs</a></li>
                    <li><a href="#deroule">D√©roul√©</a></li>
                    <li><a href="#cours">Cours</a></li>
                    <li><a href="#tp">Travaux Pratiques</a></li>
                    <li><a href="#debriefing">Debriefing</a></li>
                </ul>
            </nav>
        </div>

        <section id="objectifs">
            <h2>üéØ Objectifs P√©dagogiques de la S√©ance</h2>
            <p>√Ä la fin de cette s√©ance, vous serez capables de :</p>
            <ul>
                <li><strong>Comprendre en profondeur</strong> l'√©cosyst√®me JEE/Jakarta EE, son historique d√©taill√©, ses motivations de transition et son positionnement strat√©gique dans les architectures d'entreprise modernes, en particulier celles g√©rant des volumes de donn√©es massifs.</li>
                <li><strong>Ma√Ætriser l'installation et la configuration pas √† pas</strong> d'un environnement de d√©veloppement Java/Jakarta EE complet et fonctionnel, incluant le JDK, Maven, l'IDE IntelliJ IDEA Ultimate, et un serveur d'applications.</li>
                <li><strong>D√©ployer avec succ√®s</strong> une premi√®re application web simple mais repr√©sentative sur un serveur d'applications (WildFly/Payara), en comprenant les √©tapes du processus de build et de d√©ploiement.</li>
                <li><strong>Saisir les concepts fondamentaux et l'importance pratique</strong> de CDI (Contexts and Dependency Injection) pour la modularit√©, la testabilit√© et la maintenabilit√© des applications.</li>
                <li><strong>Appr√©hender de mani√®re concr√®te</strong> le lien intrins√®que entre les architectures JEE/Jakarta EE et les exigences sp√©cifiques des applications Big Data, en identifiant les avantages cl√©s de cette synergie.</li>
            </ul>

            <h3>Pr√©requis Essentiels :</h3>
            <ul>
                <li><strong>Connaissances solides en programmation Java :</strong>
                    <ul>
                        <li>Ma√Ætrise de la syntaxe Java de base (variables, boucles, conditions).</li>
                        <li>Compr√©hension approfondie de la Programmation Orient√©e Objet (POO) : classes, objets, h√©ritage, interfaces, polymorphisme, encapsulation.</li>
                        <li>Familiarit√© avec les collections Java (List, Set, Map) et les Streams API.</li>
                        <li>Gestion des exceptions (try-catch-finally, throws).</li>
                        <li>Notions de base sur les threads et la concurrence (bien que non centrale pour cette s√©ance, c'est un plus).</li>
                    </ul>
                </li>
                <li><strong>Compr√©hension des concepts de base du d√©veloppement web :</strong>
                    <ul>
                        <li>Fonctionnement du protocole HTTP (requ√™tes GET/POST, codes de statut, en-t√™tes).</li>
                        <li>Architecture client/serveur.</li>
                        <li>Notions de base de HTML et CSS.</li>
                    </ul>
                </li>
                <li><strong>Configuration mat√©rielle minimale recommand√©e :</strong>
                    <ul>
                        <li>Un ordinateur avec au moins 8 Go de RAM (16 Go fortement recommand√© pour le confort).</li>
                        <li>Un espace disque suffisant (au moins 20-30 Go libres pour les installations et projets).</li>
                        <li>Une connexion internet stable et rapide pour les t√©l√©chargements.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="deroule">
            <h2>‚è±Ô∏è D√©roul√© D√©taill√© de la S√©ance (4 heures)</h2>
            <p>Cette s√©ance est structur√©e pour vous offrir une immersion compl√®te et progressive dans l'univers de Java EE/Jakarta EE, avec un focus constant sur les applications Big Data.</p>
            <ul>
                <li><strong>I. Introduction et Contexte (30 minutes)</strong>
                    <ul>
                        <li><strong>1.1. Pr√©sentation du module et des objectifs (10 min) :</strong> Discussion interactive sur le programme, les attentes, et l'importance de Java/JEE dans le paysage actuel de l'ing√©nierie Big Data.</li>
                        <li><strong>1.2. Historique et √©volution de Java EE √† Jakarta EE (10 min) :</strong> Voyage dans le temps pour comprendre les racines de la plateforme et les raisons de sa transformation.</li>
                        <li><strong>1.3. Pourquoi JEE/Jakarta EE pour le Big Data ? (10 min) :</strong> Analyse des synergies et des avantages concrets de l'utilisation de ces technologies pour g√©rer des donn√©es massives.</li>
                    </ul>
                </li>
                <li><strong>II. Cours Magistral : √âcosyst√®me JEE/Jakarta EE (90 minutes)</strong>
                    <ul>
                        <li><strong>2.1. Architecture des applications d'entreprise (30 min) :</strong> Exploration des couches logiques (pr√©sentation, m√©tier, persistance, int√©gration) et des composants cl√©s de Jakarta EE (Servlets, JSP, JPA, CDI, JAX-RS, EJB). Chaque composant sera pr√©sent√© avec son r√¥le et son utilit√©.</li>
                        <li><strong>2.2. R√¥le des serveurs d'applications (30 min) :</strong> Compr√©hension approfondie du r√¥le central des serveurs comme WildFly ou Payara, leurs fonctionnalit√©s (gestion du cycle de vie, services d'infrastructure, scalabilit√©) et pourquoi ils sont indispensables.</li>
                        <li><strong>2.3. Introduction √† CDI (Contexts and Dependency Injection) (30 min) :</strong> Explication d√©taill√©e des concepts d'injection de d√©pendances et de gestion des contextes (scopes), avec des exemples de code clairs et des analogies pour faciliter la compr√©hension.</li>
                    </ul>
                </li>
                <li><strong>III. Travaux Pratiques : Mise en place de l'environnement et premi√®re application (90 minutes)</strong>
                    <ul>
                        <li><strong>TP 1 : Installation et configuration de l'environnement de d√©veloppement (30 min) :</strong> Guide pas √† pas pour installer JDK, Maven et IntelliJ IDEA, avec v√©rification de chaque √©tape.</li>
                        <li><strong>TP 2 : Installation et configuration de WildFly/Payara (30 min) :</strong> Instructions d√©taill√©es pour t√©l√©charger, d√©marrer et int√©grer le serveur d'applications √† IntelliJ IDEA.</li>
                        <li><strong>TP 3 : Cr√©ation et d√©ploiement d'une application web "Hello World" avec Jakarta EE (30 min) :</strong> Exercice pratique guid√© pour cr√©er un projet web simple dans IntelliJ, modifier une Servlet et la d√©ployer sur le serveur, en observant le r√©sultat dans le navigateur.</li>
                    </ul>
                </li>
                <li><strong>IV. Debriefing et Perspectives (30 minutes)</strong>
                    <ul>
                        <li><strong>R√©capitulatif des Apprentissages Cl√©s (10 min) :</strong> Synth√®se des points essentiels de la s√©ance.</li>
                        <li><strong>Discussion et Questions / R√©ponses (10 min) :</strong> √âchange ouvert pour clarifier les doutes et partager les exp√©riences.</li>
                        <li><strong>Pr√©paration pour la S√©ance Suivante et Ressources Suppl√©mentaires (10 min) :</strong> Pr√©sentation des objectifs de la prochaine s√©ance et des ressources pour approfondir.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="cours">
            <h2>I. Introduction et Contexte (30 min)</h2>
            <h3>1.1. Pr√©sentation du module et des objectifs (10 min)</h3>
            <p>Chers √©tudiants, bienvenue √† cette premi√®re s√©ance du module "Java JEE pour Ing√©nierie Big Data" ! Ce cours est une pierre angulaire de votre formation en 3√®me ann√©e de Big Data, car il vous plongera au c≈ìur des architectures logicielles d'entreprise, avec une emphase particuli√®re sur la gestion des donn√©es massives.</p>
            <p><strong>Pourquoi ce module est-il absolument essentiel pour vous, futurs Ing√©nieurs Big Data et experts en Cybers√©curit√© ?</strong></p>
            <ul>
                <li><strong>Le C≈ìur des Syst√®mes d'Entreprise :</strong> De tr√®s nombreuses entreprises, des startups aux multinationales, utilisent Java et les technologies JEE/Spring pour construire leurs syst√®mes dorsaux (backends) critiques. Ces syst√®mes sont souvent les points d'entr√©e et de traitement des donn√©es les plus sensibles et les plus volumineuses. Comprendre comment ils fonctionnent est indispensable.</li>
                <li><strong>Pont entre D√©veloppement et Donn√©es :</strong> Vous apprendrez √† concevoir et √† d√©velopper des applications qui ne se contentent pas de stocker des donn√©es, mais qui les ing√®rent, les transforment, les analysent et les exposent de mani√®re performante et s√©curis√©e. Nous ferons le lien direct avec des outils Big Data comme Apache Kafka (pour le streaming de donn√©es), Apache Spark (pour le traitement distribu√©), Hadoop (pour le stockage distribu√©) et diverses bases de donn√©es NoSQL (MongoDB, Cassandra, Elasticsearch).</li>
                <li><strong>Comp√©tences Hautement Demand√©es :</strong> La ma√Ætrise de Java, de l'√©cosyst√®me JEE/Jakarta EE et du framework Spring Boot, combin√©e √† une compr√©hension des architectures Big Data, vous positionnera id√©alement sur le march√© du travail pour des r√¥les d'Ing√©nieur Backend, Architecte Logiciel, D√©veloppeur Big Data, ou m√™me des postes o√π la s√©curit√© des applications est primordiale.</li>
                <li><strong>S√©curit√© par Conception :</strong> En tant que futurs experts en cybers√©curit√©, vous ne vous contenterez pas d'utiliser ces technologies, vous apprendrez √† les utiliser de mani√®re s√©curis√©e, en int√©grant les bonnes pratiques d√®s la phase de conception et de d√©veloppement.</li>
            </ul>
            <p>Notre objectif commun est de vous transformer en d√©veloppeurs capables de construire des applications d'entreprise robustes, scalables, performantes et s√©curis√©es, pr√™tes √† relever les d√©fis du monde r√©el des donn√©es massives.</p>

            <h3>1.2. Historique et √©volution de Java EE √† Jakarta EE (10 min)</h3>
            <p>Pour comprendre o√π nous allons, il est crucial de savoir d'o√π nous venons. L'histoire de Java EE est celle d'une plateforme qui a domin√© le d√©veloppement d'applications d'entreprise pendant des d√©cennies, et qui continue d'√©voluer.</p>
            <ul>
                <li><strong>Les D√©buts : J2EE (Java 2 Platform, Enterprise Edition) - Fin des ann√©es 90 / D√©but 2000</strong>
                    <ul>
                        <li><strong>Contexte :</strong> √Ä l'√©poque, le d√©veloppement d'applications d'entreprise √©tait complexe. J2EE est n√© pour standardiser et simplifier ce processus.</li>
                        <li><strong>Philosophie :</strong> "Write Once, Run Anywhere" (√âcrire une fois, ex√©cuter partout) √©tendu aux applications d'entreprise. Fournir un ensemble de sp√©cifications pour des composants r√©utilisables et des services d'infrastructure.</li>
                        <li><strong>Composants Cl√©s :</strong> EJB (Enterprise JavaBeans) √©taient au c≈ìur, avec Servlets, JSP, JDBC, JMS, etc.</li>
                        <li><strong>Critiques :</strong> Souvent per√ßu comme lourd, complexe √† configurer et √† d√©velopper, avec une courbe d'apprentissage abrupte.</li>
                    </ul>
                </li>
                <li><strong>L'√âvolution : Java EE (√† partir de la version 5) - Milieu des ann√©es 2000 √† 2017</strong>
                    <ul>
                        <li><strong>Simplification :</strong> Java EE 5 a marqu√© un tournant majeur avec l'introduction des annotations (simplifiant la configuration des EJB et Servlets) et l'all√®gement de la plateforme.</li>
                        <li><strong>Mont√©e en puissance de JPA et CDI :</strong> Ces sp√©cifications sont devenues des piliers pour la persistance et l'injection de d√©pendances, rendant le d√©veloppement plus agr√©able.</li>
                        <li><strong>Concurrence :</strong> L'√©mergence de frameworks alternatifs comme Spring a pouss√© Java EE √† s'adapter et √† se moderniser.</li>
                        <li><strong>Rythme de d√©veloppement :</strong> Le processus de standardisation via le JCP (Java Community Process) √©tait lent, ce qui freinait l'adoption rapide des nouvelles tendances (microservices, cloud-native).</li>
                    </ul>
                </li>
                <li><strong>La R√©volution : Jakarta EE - Depuis 2018</strong>
                    <ul>
                        <li><strong>Le Transfert :</strong> En 2017, Oracle, propri√©taire de Java, a pris la d√©cision strat√©gique de transf√©rer Java EE √† la Fondation Eclipse. Cette d√©cision visait √† revitaliser la plateforme en la rendant plus ouverte et communautaire.</li>
                        <li><strong>Changement de Nom :</strong> En raison de contraintes de marque avec Oracle (qui conserve la marque "Java"), Java EE a √©t√© renomm√© "Jakarta EE". Cela a √©galement impliqu√© un changement de package Java (de <code>javax.*</code> √† <code>jakarta.*</code>).</li>
                        <li><strong>Philosophie Actuelle :</strong> Jakarta EE est d√©sormais d√©velopp√© sous un mod√®le open source, avec un rythme de sortie plus rapide et une forte orientation vers les architectures modernes :
                            <ul>
                                <li><strong>Microservices :</strong> Faciliter la cr√©ation de services l√©gers et ind√©pendants.</li>
                                <li><strong>Cloud-Native :</strong> Optimisation pour le d√©ploiement dans des environnements cloud (conteneurs, Kubernetes).</li>
                                <li><strong>Communaut√© :</strong> Implication accrue de la communaut√© et des vendeurs.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
            <div class="info-box">
                <strong>Retenez bien :</strong> Lorsque nous parlons de "JEE" dans ce module, nous faisons r√©f√©rence √† l'ensemble des concepts et sp√©cifications, qu'ils soient sous l'ancienne appellation Java EE ou la nouvelle Jakarta EE. Nous travaillerons avec les versions les plus r√©centes de Jakarta EE, qui sont la continuation logique et modernis√©e de Java EE.
            </div>

            <h3>1.3. Pourquoi JEE/Jakarta EE pour le Big Data ? (10 min)</h3>
            <p>Il est l√©gitime de se demander pourquoi choisir une plateforme comme Jakarta EE, souvent per√ßue comme "entreprise" et parfois "lourde", pour des applications Big Data qui privil√©gient souvent la l√©g√®ret√© et la rapidit√© d'ex√©cution. La r√©ponse r√©side dans les forces intrins√®ques de Java et de son √©cosyst√®me, qui sont parfaitement align√©es avec les exigences du Big Data :</p>
            <ul>
                <li><strong>1. Robustesse et Fiabilit√© In√©gal√©es :</strong>
                    <ul>
                        <li>Les syst√®mes Big Data traitent des informations critiques. Une panne ou une incoh√©rence peut avoir des cons√©quences d√©sastreuses. Les sp√©cifications JEE sont con√ßues pour la r√©silience, la gestion des erreurs et la coh√©rence transactionnelle, garantissant que vos pipelines de donn√©es sont fiables m√™me sous forte contrainte.</li>
                        <li>Les serveurs d'applications fournissent un environnement stable et √©prouv√© pour des applications qui doivent fonctionner 24h/24, 7j/7.</li>
                    </ul>
                </li>
                <li><strong>2. Scalabilit√© Horizontale Native :</strong>
                    <ul>
                        <li>Les architectures JEE sont intrins√®quement con√ßues pour la scalabilit√©. Les serveurs d'applications peuvent √™tre mis en cluster, permettant de r√©partir la charge sur plusieurs machines et d'ajouter des ressources √† la vol√©e pour g√©rer des volumes de requ√™tes et de donn√©es croissants.</li>
                        <li>Ceci est fondamental pour le Big Data, o√π les besoins en capacit√© de traitement peuvent varier √©norm√©ment.</li>
                    </ul>
                </li>
                <li><strong>3. √âcosyst√®me Java Vaste et Mature :</strong>
                    <ul>
                        <li>Java est le langage de pr√©dilection de la plupart des technologies Big Data open source : Apache Hadoop, Apache Spark, Apache Kafka, Apache Flink, Elasticsearch, Cassandra, etc.</li>
                        <li>Cela signifie que vous disposez d'une multitude de biblioth√®ques, de connecteurs et d'APIs Java natives pour interagir de mani√®re fluide et performante avec tous ces syst√®mes. Pas besoin de passer par des ponts ou des wrappers moins efficaces.</li>
                        <li>La communaut√© Java est immense, offrant un support et des ressources in√©gal√©s.</li>
                    </ul>
                </li>
                <li><strong>4. Performance Optimis√©e :</strong>
                    <ul>
                        <li>Java est un langage compil√© qui s'ex√©cute sur la JVM (Java Virtual Machine), reconnue pour ses optimisations de performance (compilation JIT, garbage collection avanc√©).</li>
                        <li>Pour le traitement de donn√©es massives, chaque milliseconde compte. La performance de Java est un atout majeur pour l'ingestion, la transformation et l'analyse rapide des donn√©es.</li>
                    </ul>
                </li>
                <li><strong>5. S√©curit√© Int√©gr√©e :</strong>
                    <ul>
                        <li>Les sp√©cifications Jakarta EE incluent des m√©canismes de s√©curit√© robustes (authentification, autorisation, gestion des r√¥les, protection contre les vuln√©rabilit√©s courantes).</li>
                        <li>En tant que futurs experts en cybers√©curit√©, vous appr√©cierez la capacit√© de construire des applications Big Data qui prot√®gent les donn√©es sensibles d√®s la conception.</li>
                    </ul>
                </li>
            </ul>
            <div class="tip-box">
                <strong>Notre approche "Big Data Ready" :</strong> √Ä chaque concept que nous aborderons (persistance, services web, messagerie, etc.), nous ferons le lien direct avec la mani√®re dont il est utilis√© et optimis√© dans un contexte Big Data. Vous ne ferez pas que du "Java EE", vous ferez du "Java EE pour le Big Data".
            </div>
        </section>

        <section id="cours">
            <h2>II. Cours Magistral : √âcosyst√®me JEE/Jakarta EE (90 min)</h2>

            <h3>2.1. Architecture des applications d'entreprise: couches, composants (30 min)</h3>
            <p>Pour construire des applications complexes et maintenables, les d√©veloppeurs ont adopt√© des architectures structur√©es. L'approche la plus courante est l'architecture multi-tiers (ou N-tiers), qui divise l'application en couches logiques distinctes. Chaque couche a une responsabilit√© sp√©cifique, ce qui favorise la modularit√©, la r√©utilisabilit√© et la scalabilit√©.</p>
            <p><strong>Les Couches Logiques d'une Application d'Entreprise Typique :</strong></p>
            <ol>
                <li><strong>Couche Pr√©sentation (Frontend / Client Tier) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> C'est l'interface avec laquelle l'utilisateur interagit. Elle est responsable de l'affichage des donn√©es et de la collecte des entr√©es utilisateur.</li>
                        <li><strong>Technologies JEE/Jakarta EE :</strong>
                            <ul>
                                <li><strong>Jakarta Servlets & Jakarta Server Pages (JSP) :</strong> Permettent de g√©n√©rer des pages web dynamiques c√¥t√© serveur. Les Servlets traitent les requ√™tes HTTP, et les JSP sont utilis√©es pour la partie "vue" (affichage HTML).</li>
                                <li><strong>Jakarta Faces (JSF) :</strong> Un framework bas√© sur des composants pour construire des interfaces utilisateur web.</li>
                            </ul>
                        </li>
                        <li><strong>Technologies Modernes Compl√©mentaires :</strong> Souvent, cette couche est impl√©ment√©e avec des frameworks JavaScript c√¥t√© client comme React, Angular ou Vue.js, qui communiquent avec le backend via des APIs REST.</li>
                    </ul>
                </li>
                <li><strong>Couche M√©tier (Business Logic / Application Tier) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> C'est le "cerveau" de l'application. Elle contient toutes les r√®gles m√©tier, les algorithmes et les logiques sp√©cifiques au domaine de l'entreprise. Elle orchestre les op√©rations et assure la coh√©rence des donn√©es.</li>
                        <li><strong>Technologies JEE/Jakarta EE :</strong>
                            <ul>
                                <li><strong>Jakarta Enterprise Beans (EJB) :</strong> Composants c√¥t√© serveur qui encapsulent la logique m√©tier et fournissent des services d'entreprise (transactions, s√©curit√©, concurrence). Bien que moins utilis√©s dans les microservices l√©gers, ils restent pertinents pour des logiques m√©tier complexes et distribu√©es.</li>
                                <li><strong>Jakarta Contexts and Dependency Injection (CDI) :</strong> Un standard pour l'injection de d√©pendances et la gestion du cycle de vie des objets. Il permet de structurer la logique m√©tier en services modulaires et facilement testables.</li>
                                <li><strong>Services POJO (Plain Old Java Objects) :</strong> De plus en plus, la logique m√©tier est impl√©ment√©e dans de simples classes Java (POJO) qui sont g√©r√©es par CDI ou Spring.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Couche Persistance (Data Access / Data Tier) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> G√®re toutes les interactions avec la base de donn√©es (SQL ou NoSQL). Elle est responsable de la lecture, de l'√©criture, de la mise √† jour et de la suppression des donn√©es, en masquant les d√©tails techniques de la base de donn√©es aux couches sup√©rieures.</li>
                        <li><strong>Technologies JEE/Jakarta EE :</strong>
                            <ul>
                                <li><strong>Jakarta Persistence API (JPA) :</strong> Une sp√©cification standard pour le mapping objet-relationnel (ORM). Elle permet de manipuler des objets Java comme si c'√©taient des lignes de base de donn√©es, sans √©crire de SQL direct.</li>
                                <li><strong>Hibernate :</strong> L'impl√©mentation de r√©f√©rence et la plus populaire de JPA.</li>
                                <li><strong>JDBC (Java Database Connectivity) :</strong> L'API de bas niveau pour se connecter et interagir avec des bases de donn√©es relationnelles. JPA/Hibernate s'appuient sur JDBC.</li>
                            </ul>
                        </li>
                        <li><strong>Lien Big Data :</strong> Cette couche sera cruciale pour interagir avec des bases de donn√©es NoSQL (MongoDB, Cassandra) ou des syst√®mes de fichiers distribu√©s (HDFS).</li>
                    </ul>
                </li>
                <li><strong>Couche Int√©gration (Integration Tier) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> Permet √† l'application de communiquer avec d'autres syst√®mes externes, qu'ils soient internes √† l'entreprise ou des services tiers.</li>
                        <li><strong>Technologies JEE/Jakarta EE :</strong>
                            <ul>
                                <li><strong>Jakarta RESTful Web Services (JAX-RS) :</strong> Pour cr√©er et consommer des services web bas√©s sur l'architecture REST.</li>
                                <li><strong>Jakarta XML Web Services (JAX-WS) :</strong> Pour les services web SOAP (moins courants aujourd'hui, mais toujours pr√©sents dans les syst√®mes legacy).</li>
                                <li><strong>Jakarta Messaging (JMS) :</strong> Pour la communication asynchrone via des files ou des topics de messages (utile pour l'int√©gration avec Kafka).</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            <div class="info-box">
                Cette architecture en couches est un principe de conception fondamental. Elle permet √† chaque couche d'√©voluer ind√©pendamment et facilite la collaboration entre √©quipes. Par exemple, une √©quipe frontend peut travailler sur la couche pr√©sentation, tandis qu'une √©quipe backend se concentre sur les couches m√©tier et persistance.
            </div>

            <h3>2.2. R√¥le des serveurs d'applications (WildFly, Payara) (30 min)</h3>
            <p>Un serveur d'applications est bien plus qu'un simple serveur web. C'est un environnement d'ex√©cution complet qui fournit une multitude de services d'infrastructure aux applications d'entreprise Java. Il agit comme un "super-conteneur" pour vos composants JEE/Jakarta EE.</p>
            <p><strong>Imaginez le serveur d'applications comme un h√¥tel de luxe pour vos applications :</strong></p>
            <ul>
                <li><strong>Il g√®re l'enregistrement et le d√©part (cycle de vie) :</strong> Il sait comment d√©marrer, arr√™ter et g√©rer vos Servlets, EJB, etc. Vous n'avez pas √† vous soucier de l'initialisation ou de la destruction de ces composants.</li>
                <li><strong>Il fournit tous les services (infrastructure) :</strong>
                    <ul>
                        <li><strong>Gestion des Connexions √† la Base de Donn√©es (JDBC Connection Pooling) :</strong> Au lieu que chaque requ√™te ouvre et ferme une connexion √† la base de donn√©es (ce qui est co√ªteux), le serveur maintient un pool de connexions pr√™tes √† l'emploi. Cela am√©liore consid√©rablement les performances.</li>
                        <li><strong>Gestion des Transactions (JTA - Java Transaction API) :</strong> Il assure que les op√©rations sur la base de donn√©es sont atomiques, coh√©rentes, isol√©es et durables (propri√©t√©s ACID). Si une partie d'une transaction √©choue, toutes les modifications sont annul√©es.</li>
                        <li><strong>S√©curit√© :</strong> Il g√®re l'authentification (qui √™tes-vous ?) et l'autorisation (qu'avez-vous le droit de faire ?), souvent en s'int√©grant avec des annuaires d'entreprise (LDAP, Active Directory).</li>
                        <li><strong>Messagerie (JMS - Java Message Service) :</strong> Il fournit un syst√®me de messagerie pour la communication asynchrone entre les composants ou avec d'autres applications.</li>
                        <li><strong>Gestion des Threads et de la Concurrence :</strong> Il g√®re les threads qui ex√©cutent vos requ√™tes, assurant que plusieurs utilisateurs peuvent acc√©der √† l'application simultan√©ment sans interf√©rence.</li>
                        <li><strong>Injection de D√©pendances (CDI) :</strong> Il est le conteneur qui r√©alise l'injection de d√©pendances pour vos beans CDI.</li>
                    </ul>
                </li>
                <li><strong>Il permet de grandir (Scalabilit√© et Haute Disponibilit√©) :</strong> Les serveurs d'applications peuvent √™tre configur√©s en cluster, ce qui signifie que plusieurs instances du serveur peuvent travailler ensemble pour g√©rer une charge plus importante et assurer que l'application reste disponible m√™me si un serveur tombe en panne.</li>
                <li><strong>Il respecte les r√®gles (Conformit√© aux Sp√©cifications) :</strong> Un serveur d'applications certifi√© Jakarta EE garantit que votre application, d√©velopp√©e selon les sp√©cifications, fonctionnera correctement sur n'importe quel autre serveur certifi√©.</li>
            </ul>
            <p><strong>Exemples Concrets de Serveurs d'Applications :</strong></p>
            <ul>
                <li><strong>WildFly (anciennement JBoss AS) :</strong>
                    <ul>
                        <li><strong>D√©veloppeur :</strong> Red Hat.</li>
                        <li><strong>Caract√©ristiques :</strong> L√©ger, rapide, modulaire. Tr√®s populaire dans les environnements d'entreprise. Il est souvent utilis√© pour des applications de grande envergure.</li>
                        <li><strong>Notre choix :</strong> Nous l'utiliserons comme serveur principal pour nos TP.</li>
                    </ul>
                </li>
                <li><strong>Payara Server (bas√© sur GlassFish) :</strong>
                    <ul>
                        <li><strong>D√©veloppeur :</strong> Payara Services Ltd. (issu de la communaut√© GlassFish).</li>
                        <li><strong>Caract√©ristiques :</strong> Facile √† utiliser, orient√© cloud-native, avec des fonctionnalit√©s suppl√©mentaires pour le monitoring et la gestion des microservices.</li>
                        <li><strong>Alternative :</strong> Une excellente alternative √† WildFly, souvent appr√©ci√©e pour sa simplicit√© de d√©marrage.</li>
                    </ul>
                </li>
                <li><strong>Apache Tomcat :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> C'est un "conteneur de Servlets" ou "serveur web". Il impl√©mente les sp√©cifications Jakarta Servlet et Jakarta Server Pages (JSP).</li>
                        <li><strong>Diff√©rence avec WildFly/Payara :</strong> Tomcat n'est pas un serveur "full Jakarta EE". Il ne fournit pas nativement tous les services d'entreprise comme EJB, JTA, JMS. Pour ces services, vous devriez ajouter des biblioth√®ques tierces. Il est souvent utilis√© pour des applications web plus l√©g√®res ou des microservices REST.</li>
                    </ul>
                </li>
            </ul>
            <div class="info-box">
                Comprendre le r√¥le du serveur d'applications est fondamental. Il vous d√©charge d'une grande partie du travail d'infrastructure, vous permettant de vous concentrer sur la logique m√©tier de votre application.
            </div>

            <h3>2.3. Introduction √† CDI (Contexts and Dependency Injection) (30 min)</h3>
            <p>CDI est l'une des sp√©cifications les plus importantes et les plus utilis√©es de Jakarta EE. Elle r√©volutionne la fa√ßon dont les composants interagissent, rendant votre code plus propre, plus modulaire et beaucoup plus facile √† tester et √† maintenir. C'est le c≈ìur de l'inversion de contr√¥le dans Jakarta EE.</p>
            <p><strong>Les Deux Piliers de CDI :</strong></p>
            <h4>1. L'Injection de D√©pendances (Dependency Injection - DI)</h4>
            <p>Traditionnellement, si un objet (disons, un <code>ServiceUtilisateur</code>) a besoin d'un autre objet (disons, un <code>RepositoryUtilisateur</code> pour acc√©der √† la base de donn√©es), le <code>ServiceUtilisateur</code> est responsable de cr√©er ou de trouver une instance de <code>RepositoryUtilisateur</code>. C'est ce qu'on appelle le "couplage fort" : le service est directement li√© √† la mani√®re dont son repository est cr√©√©.</p>
            <p><strong>Probl√®mes du couplage fort :</strong></p>
            <ul>
                <li><strong>Difficile √† tester :</strong> Pour tester <code>ServiceUtilisateur</code>, vous devez aussi avoir un vrai <code>RepositoryUtilisateur</code> et une vraie base de donn√©es. C'est lent et complexe.</li>
                <li><strong>Moins flexible :</strong> Si vous voulez changer l'impl√©mentation de <code>RepositoryUtilisateur</code>, vous devez modifier <code>ServiceUtilisateur</code>.</li>
            </ul>
            <p><strong>L'approche de l'Injection de D√©pendances (DI) :</strong></p>
            <p>Avec DI, ce n'est plus l'objet qui cr√©e ses d√©pendances, mais un "conteneur" (le conteneur CDI) qui les lui fournit. L'objet d√©clare simplement qu'il a besoin de quelque chose, et le conteneur s'occupe de lui "injecter" la bonne instance.</p>
            <pre><code class="language-java">// 1. D√©finir une interface pour le Repository (bonne pratique)
public interface UtilisateurRepository {
    Utilisateur trouverParId(long id);
    void sauvegarder(Utilisateur utilisateur);
}

// 2. Impl√©mentation concr√®te du Repository
public class UtilisateurRepositoryImpl implements UtilisateurRepository {
    // Logique d'acc√®s √† la base de donn√©es
    public Utilisateur trouverParId(long id) {
        System.out.println("Recherche utilisateur dans la base de donn√©es...");
        return new Utilisateur(id, "Alice", "alice@example.com"); // Simulation
    }
    public void sauvegarder(Utilisateur utilisateur) {
        System.out.println("Sauvegarde de l'utilisateur " + utilisateur.getNom() + " en base de donn√©es.");
    }
}

// 3. Le Service qui a besoin du Repository
import jakarta.inject.Inject; // L'annotation magique de CDI

public class UtilisateurService {

    @Inject // CDI va trouver une impl√©mentation de UtilisateurRepository et l'injecter ici
    private UtilisateurRepository utilisateurRepo; // D√©claration de la d√©pendance

    public Utilisateur obtenirDetailsUtilisateur(long id) {
        System.out.println("ServiceUtilisateur: Obtention des d√©tails pour l'ID " + id);
        return utilisateurRepo.trouverParId(id);
    }

    public void creerNouvelUtilisateur(Utilisateur user) {
        System.out.println("ServiceUtilisateur: Cr√©ation d'un nouvel utilisateur.");
        utilisateurRepo.sauvegarder(user);
    }
}
                    </code></pre>
            <p><strong>Comment √ßa marche ?</strong></p>
            <ul>
                <li>L'annotation <code>@Inject</code> sur le champ <code>utilisateurRepo</code> indique √† CDI : "J'ai besoin d'une instance de <code>UtilisateurRepository</code> ici."</li>
                <li>Au d√©marrage de l'application, le conteneur CDI scanne vos classes. Quand il voit <code>@Inject UtilisateurRepository</code>, il cherche une classe qui impl√©mente <code>UtilisateurRepository</code> (ici, <code>UtilisateurRepositoryImpl</code>) et cr√©e une instance de celle-ci.</li>
                <li>Cette instance est ensuite "inject√©e" (assign√©e) au champ <code>utilisateurRepo</code> dans <code>UtilisateurService</code>.</li>
            </ul>
            <p><strong>Avantages de l'Injection de D√©pendances :</strong></p>
            <ul>
                <li><strong>Couplage Faible :</strong> <code>UtilisateurService</code> ne sait pas comment <code>UtilisateurRepositoryImpl</code> est cr√©√©. Il ne d√©pend que de l'interface <code>UtilisateurRepository</code>.</li>
                <li><strong>Testabilit√© Am√©lior√©e :</strong> Pour tester <code>UtilisateurService</code>, vous pouvez injecter une "fausse" impl√©mentation de <code>UtilisateurRepository</code> (un "mock" ou "stub") qui ne touche pas √† la base de donn√©es.</li>
                <li><strong>Flexibilit√© :</strong> Vous pouvez facilement changer l'impl√©mentation de <code>UtilisateurRepository</code> sans modifier <code>UtilisateurService</code>.</li>
                <li><strong>R√©utilisabilit√© :</strong> Les composants sont plus autonomes et peuvent √™tre r√©utilis√©s dans diff√©rents contextes.</li>
            </ul>

            <h4>2. Les Contextes (Scopes)</h4>
            <p>Les "scopes" (ou contextes) d√©finissent le cycle de vie et la visibilit√© des objets (appel√©s "beans CDI") g√©r√©s par le conteneur CDI. Ils d√©terminent combien de temps une instance d'un objet existe et quand elle est partag√©e.</p>
            <p><strong>Scopes CDI Courants :</strong></p>
            <ul>
                <li><code>@ApplicationScoped</code> :
                    <ul>
                        <li><strong>Cycle de vie :</strong> Une seule instance du bean est cr√©√©e pour toute la dur√©e de vie de l'application. Elle est partag√©e par tous les utilisateurs et toutes les requ√™tes.</li>
                        <li><strong>Quand l'utiliser :</strong> Pour des services globaux, des configurations, des caches partag√©s, ou des ressources qui doivent √™tre uniques pour toute l'application.</li>
                        <li><strong>Exemple :</strong> Un service de configuration, un compteur global de visites.</li>
                    </ul>
                    <pre><code class="language-java">import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class ConfigurationService {
    private String appName = "Mon App Big Data";
    // ...
    public String getAppName() { return appName; }
}
                    </code></pre>
                </li>
                <li><code>@RequestScoped</code> :
                    <ul>
                        <li><strong>Cycle de vie :</strong> Une nouvelle instance du bean est cr√©√©e pour chaque requ√™te HTTP entrante. Elle est d√©truite une fois la requ√™te trait√©e.</li>
                        <li><strong>Quand l'utiliser :</strong> Pour des donn√©es sp√©cifiques √† une requ√™te, des compteurs par requ√™te, ou des objets qui ne doivent pas √™tre partag√©s entre diff√©rentes requ√™tes.</li>
                        <li><strong>Exemple :</strong> Un bean qui contient les param√®tres d'une requ√™te utilisateur.</li>
                    </ul>
                    <pre><code class="language-java">import jakarta.enterprise.context.RequestScoped;
import jakarta.inject.Named; // Pour l'acc√®s depuis JSP/JSF

@Named("userRequest") // Accessible via #{userRequest.param}
@RequestScoped
public class UserRequestBean {
    private String searchParam;
    // Getters et Setters
}
                    </code></pre>
                </li>
                <li><code>@SessionScoped</code> :
                    <ul>
                        <li><strong>Cycle de vie :</strong> Une nouvelle instance du bean est cr√©√©e pour chaque session utilisateur (lorsqu'un utilisateur se connecte et interagit avec l'application). Elle persiste tant que la session est active.</li>
                        <li><strong>Quand l'utiliser :</strong> Pour stocker des informations sp√©cifiques √† un utilisateur pendant sa session (panier d'achat, pr√©f√©rences utilisateur).</li>
                        <li><strong>Exemple :</strong> Un bean g√©rant le panier d'achat d'un utilisateur.</li>
                    </ul>
                    <pre><code class="language-java">import jakarta.enterprise.context.SessionScoped;
import java.io.Serializable; // Les beans de session doivent √™tre s√©rialisables

@SessionScoped
public class ShoppingCart implements Serializable {
    private List&lt;String&gt; items = new ArrayList&lt;&gt;();
    // ...
}
                    </code></pre>
                </li>
                <li><code>@Dependent</code> (par d√©faut) :
                    <ul>
                        <li><strong>Cycle de vie :</strong> Le bean n'a pas de cycle de vie propre. Son cycle de vie est li√© √† celui de l'objet qui l'injecte. Si l'objet injecteur est d√©truit, le bean <code>@Dependent</code> est aussi d√©truit.</li>
                        <li><strong>Quand l'utiliser :</strong> Pour des objets l√©gers qui ne n√©cessitent pas de gestion de cycle de vie complexe et qui sont sp√©cifiques √† l'objet qui les utilise.</li>
                    </ul>
                </li>
            </ul>
            <div class="tip-box">
                CDI est le "couteau suisse" de l'architecture Jakarta EE. Il simplifie √©norm√©ment la gestion des d√©pendances et des cycles de vie, rendant le d√©veloppement plus rapide et le code plus robuste. Nous l'utiliserons constamment tout au long du module.
            </div>

            <h3>2.4. Pr√©sentation des sp√©cifications cl√©s de Jakarta EE (30 min)</h3>
            <p>Jakarta EE n'est pas un produit monolithique, mais une collection de sp√©cifications. Chaque sp√©cification est un contrat qui d√©finit un ensemble d'APIs (interfaces Java) et de comportements que les impl√©mentations (comme WildFly ou Payara) doivent respecter. Cela garantit l'interop√©rabilit√© et la portabilit√© de vos applications.</p>
            <p>Voici un aper√ßu des sp√©cifications les plus importantes que nous allons rencontrer et utiliser :</p>
            <ul>
                <li><strong>Jakarta Servlet (<code>jakarta.servlet.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> La fondation de toute application web Java. Elle d√©finit comment les composants Java (Servlets) peuvent traiter les requ√™tes HTTP et g√©n√©rer des r√©ponses.</li>
                        <li><strong>Utilit√© Big Data :</strong> Essentielle pour cr√©er des points d'entr√©e (endpoints) pour l'ingestion de donn√©es via HTTP (par exemple, des APIs REST pour recevoir des logs ou des √©v√©nements IoT).</li>
                    </ul>
                </li>
                <li><strong>Jakarta Server Pages (JSP) (<code>jakarta.servlet.jsp.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> Permet d'int√©grer du code Java directement dans des pages HTML. Le serveur d'applications compile les JSP en Servlets.</li>
                        <li><strong>Utilit√© Big Data :</strong> Pour cr√©er des dashboards web dynamiques affichant des m√©triques ou des visualisations de donn√©es Big Data.</li>
                    </ul>
                </li>
                <li><strong>Jakarta Expression Language (EL) (<code>jakarta.el.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> Un langage simple utilis√© principalement dans les JSP (et JSF) pour acc√©der aux propri√©t√©s des beans (objets Java) et ex√©cuter des expressions.</li>
                        <li><strong>Exemple :</strong> <code>&lt;h1&gt;Bonjour, #{user.name}!&lt;/h1&gt;</code></li>
                    </ul>
                </li>
                <li><strong>Jakarta Standard Tag Library (JSTL) (<code>jakarta.servlet.jsp.jstl.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> Une biblioth√®que de tags JSP standardis√©s qui simplifient les t√¢ches courantes comme les boucles, les conditions, la manipulation de cha√Ænes, etc., r√©duisant ainsi le besoin de code Java "scriptlet" dans les JSP.</li>
                    </ul>
                </li>
                <li><strong>Jakarta Persistence (JPA) (<code>jakarta.persistence.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> La sp√©cification pour le mapping objet-relationnel (ORM). Elle permet aux d√©veloppeurs de manipuler des objets Java comme s'ils √©taient des enregistrements de base de donn√©es, sans √©crire de SQL direct.</li>
                        <li><strong>Utilit√© Big Data :</strong> Pour la persistance des donn√©es transactionnelles dans des bases SQL (PostgreSQL, MySQL) qui peuvent coexister avec des syst√®mes NoSQL dans une architecture polyglotte.</li>
                    </ul>
                </li>
                <li><strong>Jakarta Contexts and Dependency Injection (CDI) (<code>jakarta.enterprise.context.*</code>, <code>jakarta.inject.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> Le framework d'injection de d√©pendances et de gestion des scopes que nous venons de d√©tailler. C'est un pilier pour la modularit√©.</li>
                        <li><strong>Utilit√© Big Data :</strong> Pour injecter des clients de bases de donn√©es NoSQL, des producteurs/consommateurs Kafka, ou des services de traitement de donn√©es dans vos composants m√©tier.</li>
                    </ul>
                </li>
                <li><strong>Jakarta RESTful Web Services (JAX-RS) (<code>jakarta.ws.rs.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> Sp√©cification pour la cr√©ation de services web RESTful. Elle permet de mapper des m√©thodes Java √† des chemins d'URL et des verbes HTTP (GET, POST, PUT, DELETE).</li>
                        <li><strong>Utilit√© Big Data :</strong> Indispensable pour construire des APIs d'ingestion de donn√©es (Data Ingestion APIs) ou des APIs d'exposition de donn√©es (Data Exposure APIs) pour les applications clientes ou d'autres services.</li>
                    </ul>
                </li>
                <li><strong>Jakarta Enterprise Beans (EJB) (<code>jakarta.ejb.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> Composants c√¥t√© serveur qui encapsulent la logique m√©tier et g√®rent des aspects d'entreprise comme les transactions, la s√©curit√©, la concurrence et la messagerie (avec les Message-Driven Beans).</li>
                        <li><strong>Utilit√© Big Data :</strong> Pour des logiques m√©tier complexes n√©cessitant des transactions distribu√©es ou des traitements asynchrones fiables (par exemple, pour des op√©rations de transformation de donn√©es critiques).</li>
                    </ul>
                </li>
                <li><strong>Jakarta Transactions (JTA) (<code>jakarta.transaction.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> API pour la gestion des transactions distribu√©es, c'est-√†-dire des transactions qui s'√©tendent sur plusieurs ressources (plusieurs bases de donn√©es, syst√®mes de messagerie, etc.).</li>
                        <li><strong>Utilit√© Big Data :</strong> Crucial pour garantir la coh√©rence des donn√©es dans des architectures distribu√©es o√π les donn√©es peuvent √™tre stock√©es dans diff√©rents syst√®mes (SQL et NoSQL).</li>
                    </ul>
                </li>
                <li><strong>Jakarta Messaging (JMS) (<code>jakarta.jms.*</code>) :</strong>
                    <ul>
                        <li><strong>R√¥le :</strong> API pour la messagerie asynchrone. Elle permet aux applications d'envoyer et de recevoir des messages de mani√®re fiable via des files (queues) ou des sujets (topics).</li>
                        <li><strong>Utilit√© Big Data :</strong> Peut √™tre utilis√©e comme un pont vers des syst√®mes de messagerie Big Data comme Kafka, ou pour des communications internes asynchrones dans des pipelines de donn√©es.</li>
                    </ul>
                </li>
            </ul>
            <div class="info-box">
                Chacune de ces sp√©cifications r√©sout un probl√®me sp√©cifique dans le d√©veloppement d'applications d'entreprise. En les combinant, vous pouvez construire des syst√®mes tr√®s puissants et complexes. Ne vous inqui√©tez pas si tout ne semble pas clair d√®s maintenant ; nous les explorerons en d√©tail au fur et √† mesure du module.
            </div>
        </section>

        <section id="tp" class="tp-section">
            <h2>III. Travaux Pratiques : Mise en place de l'environnement et premi√®re application (90 min)</h2>
            <p>Cette section est la plus pratique de la s√©ance. L'objectif est de vous rendre autonome dans la mise en place de votre environnement de d√©veloppement Java/Jakarta EE. Suivez attentivement chaque √©tape. N'h√©sitez pas √† demander de l'aide si vous rencontrez des difficult√©s.</p>

            <h3>Pr√©paration Initiale :</h3>
            <ul>
                <li><strong>Connexion Internet :</strong> Assurez-vous d'avoir une connexion internet stable et rapide. Nous allons t√©l√©charger plusieurs Go de logiciels.</li>
                <li><strong>Droits Administrateur :</strong> Vous aurez probablement besoin de droits administrateur sur votre machine pour installer le JDK et configurer les variables d'environnement.</li>
                <li><strong>Espace Disque :</strong> V√©rifiez que vous avez au moins 20-30 Go d'espace disque libre.</li>
                <li><strong>D√©sactivation Temporaire du Pare-feu/Antivirus :</strong> Si vous rencontrez des probl√®mes de t√©l√©chargement ou de communication r√©seau entre IntelliJ et WildFly, essayez de d√©sactiver temporairement votre pare-feu ou antivirus (avec prudence et en le r√©activant apr√®s).</li>
            </ul>

            <h3>TP 1 : Installation et configuration de l'environnement de d√©veloppement (30 min)</h3>
            <div class="tp-step">
                <h4>Objectif :</h4>
                <p>Installer les outils fondamentaux : le kit de d√©veloppement Java (JDK), l'outil de gestion de projet Maven, et l'environnement de d√©veloppement int√©gr√© (IDE) IntelliJ IDEA Ultimate.</p>
                <ol>
                    <li><strong>Installation du JDK (Java Development Kit) :</strong>
                        <p>Le JDK est la base de tout d√©veloppement Java. Il contient le compilateur Java (<code>javac</code>), la machine virtuelle Java (JVM - <code>java</code>), et d'autres outils essentiels.</p>
                        <ul>
                            <li><strong>Choix de la version :</strong> Nous recommandons une version LTS (Long Term Support) d'OpenJDK, comme Java 17 ou Java 21. Ces versions b√©n√©ficient d'un support √©tendu et sont tr√®s stables.</li>
                            <li><strong>T√©l√©chargement :</strong> Rendez-vous sur <a href="https://adoptium.net/temurin/releases/" target="_blank">Adoptium Temurin</a>. C'est une source fiable et open source d'OpenJDK.
                                <ul>
                                    <li>S√©lectionnez la version LTS souhait√©e (ex: "JDK 17 (LTS)" ou "JDK 21 (LTS)").</li>
                                    <li>Choisissez votre syst√®me d'exploitation (Windows, macOS, Linux) et l'architecture (x64).</li>
                                    <li>T√©l√©chargez le fichier d'installation (<code>.msi</code> pour Windows, <code>.pkg</code> pour macOS, <code>.tar.gz</code> ou <code>.deb</code>/<code>.rpm</code> pour Linux).</li>
                                </ul>
                            </li>
                            <li><strong>Installation :</strong>
                                <ul>
                                    <li><strong>Windows :</strong> Ex√©cutez le fichier <code>.msi</code> et suivez les instructions de l'assistant. Laissez les options par d√©faut.</li>
                                    <li><strong>macOS :</strong> Ex√©cutez le fichier <code>.pkg</code> et suivez les instructions.</li>
                                    <li><strong>Linux :</strong> Si vous avez t√©l√©charg√© un <code>.tar.gz</code>, d√©compressez-le dans un r√©pertoire comme <code>/opt/jdk-X.Y.Z</code>. Si vous utilisez un gestionnaire de paquets (<code>apt</code>, <code>yum</code>), utilisez-le (ex: <code>sudo apt install openjdk-17-jdk</code>).</li>
                                </ul>
                            </li>
                            <li><strong>V√©rification de l'installation :</strong>
                                <ul>
                                    <li>Ouvrez un <strong>nouveau</strong> terminal (Invite de commandes sur Windows, Terminal sur macOS/Linux).</li>
                                    <li>Tapez la commande : <code>java -version</code>. Vous devriez voir la version du JDK que vous venez d'installer (ex: "openjdk version "17.0.X"").</li>
                                    <li>Tapez la commande : <code>javac -version</code>. Vous devriez voir la m√™me version. Si <code>javac</code> n'est pas trouv√©, c'est que votre variable <code>PATH</code> n'est pas correctement configur√©e.</li>
                                </ul>
                            </li>
                            <li><strong>Configuration de la variable d'environnement JAVA_HOME (Tr√®s Important !) :</strong>
                                <p>De nombreux outils Java (y compris Maven et les serveurs d'applications) s'appuient sur la variable d'environnement <code>JAVA_HOME</code> pour trouver votre installation du JDK.</p>
                                <ul>
                                    <li><strong>Windows :</strong>
                                        <ol>
                                            <li>Recherchez "Modifier les variables d'environnement syst√®me" dans le menu D√©marrer.</li>
                                            <li>Cliquez sur "Variables d'environnement...".</li>
                                            <li>Dans la section "Variables syst√®me", cliquez sur "Nouvelle..." pour cr√©er <code>JAVA_HOME</code>.
                                                <ul>
                                                    <li>Nom de la variable : <code>JAVA_HOME</code></li>
                                                    <li>Valeur de la variable : Le chemin complet vers le r√©pertoire racine de votre JDK (ex: <code>C:\Program Files\Eclipse Adoptium\jdk-17.0.X.Y-hotspot</code>).</li>
                                                </ul>
                                            </li>
                                            <li>Ensuite, trouvez la variable <code>Path</code> dans les "Variables syst√®me", s√©lectionnez-la et cliquez sur "Modifier...".</li>
                                            <li>Cliquez sur "Nouveau" et ajoutez <code>%JAVA_HOME%\bin</code>. D√©placez-le en haut de la liste si possible.</li>
                                            <li>Cliquez sur OK partout pour fermer les fen√™tres.</li>
                                        </ol>
                                    </li>
                                    <li><strong>macOS/Linux :</strong>
                                        <ol>
                                            <li>Ouvrez votre fichier de configuration de shell (<code>~/.bash_profile</code>, <code>~/.zshrc</code>, ou <code>~/.bashrc</code>).</li>
                                            <li>Ajoutez les lignes suivantes (adaptez le chemin) :
                                                <pre><code class="language-bash">export JAVA_HOME=/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home # Exemple pour macOS
export PATH=$JAVA_HOME/bin:$PATH
                                                </code></pre>
                                            </li>
                                            <li>Enregistrez le fichier et sourcez-le (ex: <code>source ~/.zshrc</code>) ou ouvrez un nouveau terminal.</li>
                                        </ol>
                                    </li>
                                </ul>
                                <p><strong>V√©rification finale :</strong> Ouvrez un <strong>nouveau</strong> terminal et tapez <code>echo %JAVA_HOME%</code> (Windows) ou <code>echo $JAVA_HOME</code> (Linux/macOS). Le chemin de votre JDK devrait s'afficher.</p>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Installation de Maven :</strong>
                        <p>Maven est un outil puissant de gestion de projet et de build pour Java. Il g√®re les d√©pendances (biblioth√®ques externes), compile votre code, ex√©cute les tests et package votre application.</p>
                        <ul>
                            <li><strong>T√©l√©chargement :</strong> Rendez-vous sur <a href="https://maven.apache.org/download.cgi" target="_blank">le site officiel d'Apache Maven</a>.
                                <ul>
                                    <li>T√©l√©chargez l'archive binaire (<code>apache-maven-X.Y.Z-bin.zip</code> ou <code>.tar.gz</code>).</li>
                                </ul>
                            </li>
                            <li><strong>Installation :</strong>
                                <ul>
                                    <li>D√©compressez l'archive dans un r√©pertoire facile d'acc√®s (ex: <code>C:\apache-maven-3.9.X</code> sur Windows, <code>/opt/apache-maven-3.9.X</code> sur Linux/macOS).</li>
                                </ul>
                            </li>
                            <li><strong>Configuration de la variable d'environnement M2_HOME et PATH :</strong>
                                <p>Similaire √† <code>JAVA_HOME</code>, Maven a besoin de ses propres variables.</p>
                                <ul>
                                    <li><strong>Windows :</strong>
                                        <ol>
                                            <li>Dans les "Variables d'environnement syst√®me", cr√©ez une nouvelle variable syst√®me :
                                                <ul>
                                                    <li>Nom de la variable : <code>M2_HOME</code></li>
                                                    <li>Valeur de la variable : Le chemin complet vers le r√©pertoire racine de Maven (ex: <code>C:\apache-maven-3.9.X</code>).</li>
                                                </ul>
                                            </li>
                                            <li>Modifiez la variable <code>Path</code> et ajoutez <code>%M2_HOME%\bin</code>.</li>
                                            <li>Cliquez sur OK partout.</li>
                                        </ol>
                                    </li>
                                    <li><strong>macOS/Linux :</strong>
                                        <ol>
                                            <li>Ajoutez les lignes suivantes √† votre fichier de configuration de shell (<code>~/.bash_profile</code>, <code>~/.zshrc</code>, etc.) :
                                                <pre><code class="language-bash">export M2_HOME=/opt/apache-maven-3.9.X # Adaptez le chemin
export PATH=$M2_HOME/bin:$PATH
                                                </code></pre>
                                            </li>
                                            <li>Enregistrez et sourcez le fichier, ou ouvrez un nouveau terminal.</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                            <li><strong>V√©rification de l'installation :</strong>
                                <ul>
                                    <li>Ouvrez un <strong>nouveau</strong> terminal.</li>
                                    <li>Tapez la commande : <code>mvn -version</code>. Vous devriez voir la version de Maven, ainsi que la version du JDK qu'il utilise. Si tout est correct, vous √™tes pr√™t !</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Installation d'IntelliJ IDEA Ultimate Edition :</strong>
                        <p>IntelliJ IDEA est l'IDE (Integrated Development Environment) le plus populaire et le plus puissant pour le d√©veloppement Java. La version Ultimate est n√©cessaire pour le support complet de Jakarta EE et des serveurs d'applications.</p>
                        <ul>
                            <li><strong>T√©l√©chargement :</strong> Rendez-vous sur <a href="https://www.jetbrains.com/idea/download/" target="_blank">le site de JetBrains</a>.
                                <ul>
                                    <li>T√©l√©chargez la version "Ultimate".</li>
                                    <li><strong>Licence √âtudiante :</strong> JetBrains offre des licences gratuites pour les √©tudiants. Cherchez "JetBrains Free Educational Licenses" sur Google et suivez les instructions pour obtenir la v√¥tre. C'est un investissement qui en vaut la peine !</li>
                                </ul>
                            </li>
                            <li><strong>Installation :</strong> Ex√©cutez le fichier d'installation et suivez les instructions. Laissez les options par d√©faut.</li>
                            <li><strong>Premier Lancement :</strong>
                                <ul>
                                    <li>Lancez IntelliJ IDEA.</li>
                                    <li>Lors du premier d√©marrage, vous serez guid√© pour configurer les param√®tres de base (th√®me clair/sombre, plugins recommand√©s). Vous pouvez laisser les options par d√©faut pour l'instant.</li>
                                    <li>Connectez-vous avec votre licence JetBrains si vous en avez une.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>
            </div>

            <h3>TP 2 : Installation et configuration de WildFly/Payara (30 min)</h3>
            <div class="tp-step">
                <h4>Objectif :</h4>
                <p>Installer et d√©marrer un serveur d'applications Jakarta EE, puis l'int√©grer √† IntelliJ IDEA pour faciliter le d√©ploiement de vos applications.</p>
                <ol>
                    <li><strong>T√©l√©chargement de WildFly :</strong>
                        <p>WildFly est notre serveur d'applications de choix pour ce module. Il est l√©ger, rapide et supporte toutes les sp√©cifications Jakarta EE.</p>
                        <ul>
                            <li><strong>T√©l√©chargement :</strong> Rendez-vous sur <a href="https://www.wildfly.org/downloads/" target="_blank">le site officiel de WildFly</a>.
                                <ul>
                                    <li>Cherchez la derni√®re version stable (ex: WildFly 29 ou 30).</li>
                                    <li>T√©l√©chargez la version "Jakarta EE Full & Web Distribution" (c'est la version compl√®te qui inclut toutes les sp√©cifications dont nous aurons besoin).</li>
                                </ul>
                            </li>
                            <li><strong>Installation :</strong>
                                <ul>
                                    <li>D√©compressez l'archive t√©l√©charg√©e dans un r√©pertoire facile d'acc√®s et sans espaces dans le nom (ex: <code>C:\wildfly-30.0.0.Final</code> sur Windows, <code>~/wildfly-30.0.0.Final</code> sur Linux/macOS). √âvitez les r√©pertoires comme "Program Files" pour plus de simplicit√©.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>D√©marrage de WildFly (Test Manuel) :</strong>
                        <p>Avant de l'int√©grer √† IntelliJ, v√©rifions que WildFly d√©marre correctement de mani√®re autonome.</p>
                        <ul>
                            <li>Ouvrez un <strong>nouveau</strong> terminal.</li>
                            <li>Naviguez jusqu'au r√©pertoire <code>bin</code> de votre installation WildFly.
                                <pre><code class="language-bash">cd C:\wildfly-30.0.0.Final\bin   # Pour Windows
./standalone.sh                 # Pour Linux/macOS
                                </code></pre>
                            </li>
                            <li>Ex√©cutez la commande de d√©marrage :
                                <ul>
                                    <li><strong>Windows :</strong> Tapez <code>standalone.bat</code> et appuyez sur Entr√©e.</li>
                                    <li><strong>Linux/macOS :</strong> Tapez <code>./standalone.sh</code> et appuyez sur Entr√©e.</li>
                                </ul>
                            </li>
                            <li><strong>Observation des logs :</strong> Le terminal affichera de nombreux messages de log. Attendez de voir un message similaire √† :
                                <pre><code>...
INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly (WildFly Core 22.0.0.Final) started in Xms - Started 123 of 456 services (X services are lazy, passive or on-demand)
...
                                </code></pre>
                                <p>Ce message indique que le serveur a d√©marr√© avec succ√®s.</p>
                            </li>
                            <li><strong>V√©rification dans le navigateur :</strong> Ouvrez votre navigateur web pr√©f√©r√© et acc√©dez √† l'adresse : <code>http://localhost:8080</code>. Vous devriez voir la page d'accueil par d√©faut de WildFly.</li>
                            <li><strong>Arr√™t de WildFly :</strong> Dans le terminal o√π WildFly est en cours d'ex√©cution, appuyez sur <code>Ctrl+C</code>. Le serveur devrait s'arr√™ter proprement.</li>
                        </ul>
                    </li>
                    <li><strong>Configuration de WildFly dans IntelliJ IDEA :</strong>
                        <p>IntelliJ IDEA peut g√©rer le d√©marrage, l'arr√™t et le d√©ploiement de vos applications sur WildFly directement depuis l'IDE, ce qui est tr√®s pratique.</p>
                        <ul>
                            <li>Lancez IntelliJ IDEA.</li>
                            <li>Allez dans le menu <code>File &gt; Settings</code> (sur Windows/Linux) ou <code>IntelliJ IDEA &gt; Preferences</code> (sur macOS).</li>
                            <li>Dans la fen√™tre des param√®tres, naviguez dans l'arborescence de gauche : <code>Build, Execution, Deployment &gt; Application Servers</code>.</li>
                            <li>Cliquez sur le bouton <code>+</code> (Ajouter) en haut de la fen√™tre centrale.</li>
                            <li>Dans le menu d√©roulant, s√©lectionnez <code>WildFly Server &gt; Local</code>.</li>
                            <li>Une nouvelle fen√™tre "WildFly Server" s'ouvre. Cliquez sur le bouton <code>...</code> √† c√¥t√© du champ "Application Server Home".</li>
                            <li>Naviguez jusqu'au r√©pertoire racine de votre installation WildFly (celui o√π vous avez d√©compress√© l'archive, ex: <code>C:\wildfly-30.0.0.Final</code>).</li>
                            <li>Cliquez sur <code>OK</code>. IntelliJ devrait d√©tecter la version de WildFly.</li>
                            <li>Cliquez sur <code>Apply</code> puis <code>OK</code> pour fermer les fen√™tres de param√®tres.</li>
                            <li>Votre serveur WildFly est maintenant configur√© dans IntelliJ IDEA !</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <h3>TP 3 : Cr√©ation et d√©ploiement d'une application web "Hello World" avec Jakarta EE (30 min)</h3>
            <div class="tp-step">
                <h4>Objectif :</h4>
                <p>Cr√©er votre toute premi√®re application web Jakarta EE, la modifier l√©g√®rement, et la d√©ployer sur le serveur WildFly que vous venez de configurer, le tout depuis IntelliJ IDEA.</p>
                <ol>
                    <li><strong>Cr√©ation d'un nouveau projet dans IntelliJ IDEA :</strong>
                        <ul>
                            <li>Dans l'√©cran d'accueil d'IntelliJ IDEA, cliquez sur <code>New Project</code>. Si vous √™tes d√©j√† dans un projet, allez dans <code>File &gt; New &gt; Project...</code>.</li>
                            <li>Dans le panneau de gauche de la fen√™tre "New Project", s√©lectionnez <code>Jakarta EE</code>.</li>
                            <li>Configurez les options suivantes dans le panneau de droite :
                                <ul>
                                    <li><strong>Name :</strong> <code>MonPremierJakartaEEApp</code> (ou tout autre nom significatif).</li>
                                    <li><strong>Location :</strong> Choisissez un r√©pertoire sur votre disque o√π le projet sera cr√©√© (ex: <code>C:\Users\VotreNom\IdeaProjects\MonPremierJakartaEEApp</code>).</li>
                                    <li><strong>Build system :</strong> S√©lectionnez <code>Maven</code>. C'est le syst√®me de build que nous utiliserons.</li>
                                    <li><strong>JDK :</strong> Assurez-vous que le JDK que vous avez install√© (ex: 17 ou 21) est s√©lectionn√©. Si ce n'est pas le cas, cliquez sur "Add JDK..." et naviguez vers votre installation.</li>
                                    <li><strong>Jakarta EE Version :</strong> Choisissez la version de Jakarta EE qui correspond √† votre WildFly (ex: <code>Jakarta EE 9.1</code> ou <code>Jakarta EE 10</code>). WildFly 29/30 supporte Jakarta EE 10.</li>
                                    <li><strong>Template :</strong> S√©lectionnez <code>Web Application</code>. C'est le template de base pour une application web.</li>
                                    <li><strong>Dependencies :</strong> Dans la liste des d√©pendances, assurez-vous que <code>Jakarta RESTful Web Services</code> (JAX-RS) et <code>Jakarta Servlet</code> sont coch√©s. Ces deux-l√† sont essentiels pour une application web de base.</li>
                                </ul>
                            </li>
                            <li>Cliquez sur le bouton <code>Create</code>.</li>
                            <li>IntelliJ va maintenant g√©n√©rer la structure du projet et t√©l√©charger toutes les d√©pendances Maven n√©cessaires. Cela peut prendre quelques instants, soyez patient.</li>
                        </ul>
                    </li>
                    <li><strong>Exploration de la structure du projet :</strong>
                        <p>Une fois le projet cr√©√©, IntelliJ affichera sa structure dans la fen√™tre "Project" (g√©n√©ralement √† gauche).</p>
                        <ul>
                            <li>Ouvrez le fichier <code>pom.xml</code> (situ√© √† la racine de votre projet). C'est le fichier de configuration principal de Maven. Il d√©clare les informations de votre projet, ses d√©pendances (les biblioth√®ques externes qu'il utilise) et comment il doit √™tre construit. Vous verrez les d√©pendances pour <code>jakarta.servlet-api</code> et <code>jakarta.ws.rs-api</code> que vous avez s√©lectionn√©es.</li>
                            <li>Naviguez vers <code>src/main/webapp/index.jsp</code>. C'est la page d'accueil par d√©faut de votre application web. C'est une JSP (Java Server Page).</li>
                            <li>Naviguez vers <code>src/main/java/com/example/MonPremierJakartaEEApp/HelloServlet.java</code> (le nom du package <code>com.example.MonPremierJakartaEEApp</code> sera bas√© sur le nom de votre projet). C'est une Servlet Java simple, g√©n√©r√©e par le template, qui r√©pond √† l'URL <code>/hello-servlet</code>.</li>
                        </ul>
                    </li>
                    <li><strong>Modification de la Servlet (facultatif, pour tester) :</strong>
                        <p>Nous allons modifier le message de la Servlet pour le personnaliser et voir le changement apr√®s d√©ploiement.</p>
                        <ul>
                            <li>Ouvrez le fichier <code>HelloServlet.java</code>.</li>
                            <li>Localisez la m√©thode <code>doGet</code>. C'est cette m√©thode qui est appel√©e lorsque votre Servlet re√ßoit une requ√™te HTTP GET.</li>
                            <li>Modifiez la ligne qui d√©finit le message, par exemple :
                                <pre><code class="language-java">package com.example.MonPremierJakartaEEApp; // Votre package peut √™tre diff√©rent

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet(name = "helloServlet", value = "/hello-servlet")
public class HelloServlet extends HttpServlet {
    private String message;

    public void init() {
        // Message initialis√© une seule fois au d√©marrage de la Servlet
        message = "Bonjour du monde de Jakarta EE et du Big Data !"; // &lt;-- MODIFIEZ CETTE LIGNE
    }

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        response.setContentType("text/html"); // Indique au navigateur que la r√©ponse est du HTML

        // R√©cup√®re un objet PrintWriter pour √©crire la r√©ponse HTML
        PrintWriter out = response.getWriter();
        out.println("&lt;html&gt;&lt;body&gt;");
        out.println("&lt;h1&gt;" + message + "&lt;/h1&gt;"); // Affiche le message
        out.println("&lt;p&gt;Ceci est une application web Jakarta EE simple, pr√™te pour les d√©fis du Big Data.&lt;/p&gt;");
        out.println("&lt;/body&gt;&lt;/html&gt;");
    }

    public void destroy() {
        // M√©thode appel√©e lors de l'arr√™t de la Servlet
    }
}
                                </code></pre>
                            </li>
                            <li>Enregistrez le fichier (<code>Ctrl+S</code> ou <code>Cmd+S</code>).</li>
                        </ul>
                    </li>
                    <li><strong>Configuration du d√©ploiement dans IntelliJ IDEA :</strong>
                        <p>Maintenant, nous allons dire √† IntelliJ comment d√©ployer votre application sur WildFly.</p>
                        <ul>
                            <li>En haut √† droite de la fen√™tre IntelliJ, √† c√¥t√© du bouton "Run" (un triangle vert), cliquez sur le menu d√©roulant et s√©lectionnez <code>Add Configuration...</code>.</li>
                            <li>Dans la fen√™tre "Run/Debug Configurations", cliquez sur le bouton <code>+</code> (Ajouter une nouvelle configuration) dans le coin sup√©rieur gauche.</li>
                            <li>Dans la liste des types de configuration, s√©lectionnez <code>WildFly Server &gt; Local</code>.</li>
                            <li>Une nouvelle configuration "Unnamed" appara√Æt.
                                <ul>
                                    <li><strong>Name :</strong> Donnez un nom significatif √† cette configuration, par exemple <code>WildFly Local Deployment</code>.</li>
                                    <li><strong>Server :</strong> Assurez-vous que votre instance WildFly configur√©e au TP2 est s√©lectionn√©e.</li>
                                </ul>
                            </li>
                            <li>Maintenant, cliquez sur l'onglet <code>Deployment</code> (situ√© au milieu de la fen√™tre).</li>
                            <li>Cliquez sur le bouton <code>+</code> (Ajouter un artefact) dans la section "Deploy at the server startup".</li>
                            <li>Dans le menu d√©roulant, s√©lectionnez <code>Artifact...</code>.</li>
                            <li>Une liste d'artefacts disponibles s'affiche. Choisissez l'artefact WAR de votre projet. Il devrait avoir un nom similaire √† <code>MonPremierJakartaEEApp:war exploded</code>. (Le suffixe "exploded" signifie que le contenu du WAR sera d√©compress√© dans un r√©pertoire, ce qui est plus rapide pour le d√©veloppement). Cliquez sur <code>OK</code>.</li>
                            <li>Dans le champ <code>Application context</code>, vous verrez probablement <code>/MonPremierJakartaEEApp_war_exploded</code>. C'est le chemin d'acc√®s par d√©faut de votre application. Vous pouvez le simplifier pour le rendre plus facile √† taper dans le navigateur, par exemple, changez-le en <code>/app</code> ou <code>/monapp</code>. C'est le chemin qui sera ajout√© apr√®s <code>localhost:8080</code>.</li>
                            <li>Cliquez sur <code>Apply</code> puis <code>OK</code> pour enregistrer la configuration.</li>
                        </ul>
                    </li>
                    <li><strong>D√©ploiement et ex√©cution :</strong>
                        <p>C'est le moment de v√©rit√© !</p>
                        <ul>
                            <li>Assurez-vous que votre configuration <code>WildFly Local Deployment</code> est s√©lectionn√©e dans le menu d√©roulant en haut √† droite.</li>
                            <li>Cliquez sur le bouton "Run" (le triangle vert) √† c√¥t√© de cette configuration.</li>
                            <li><strong>Observation :</strong>
                                <ul>
                                    <li>IntelliJ va d'abord construire votre projet Maven. Vous verrez des messages dans la fen√™tre "Build" en bas.</li>
                                    <li>Ensuite, il va d√©marrer le serveur WildFly (si ce n'est pas d√©j√† fait). Vous verrez les logs de WildFly appara√Ætre dans la fen√™tre "Run" d'IntelliJ.</li>
                                    <li>Une fois WildFly d√©marr√© et votre application d√©ploy√©e, IntelliJ devrait automatiquement ouvrir votre navigateur web.</li>
                                </ul>
                            </li>
                            <li><strong>Acc√®s √† l'application :</strong>
                                <ul>
                                    <li>L'URL dans votre navigateur devrait ressembler √† : <code>http://localhost:8080/votre_contexte_application/hello-servlet</code> (par exemple, <code>http://localhost:8080/app/hello-servlet</code> si vous avez d√©fini le contexte sur <code>/app</code>).</li>
                                    <li>Vous devriez voir le message personnalis√© que vous avez √©crit dans la Servlet : "Bonjour du monde de Jakarta EE et du Big Data !".</li>
                                </ul>
                            </li>
                            <li><strong>Arr√™t de l'application :</strong> Pour arr√™ter le serveur et l'application, cliquez sur le bouton "Stop" (le carr√© rouge) dans la barre d'outils d'IntelliJ.</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </section>

        <section id="debriefing">
            <h2>IV. Debriefing et Perspectives (30 min)</h2>

            <h3>R√©capitulatif des Apprentissages Cl√©s :</h3>
            <p>F√©licitations ! Vous avez franchi une √©tape majeure dans votre parcours de d√©veloppeur d'applications d'entreprise et Big Data. R√©capitulons ce que nous avons accompli :</p>
            <ul>
                <li>Nous avons voyag√© √† travers l'histoire de Java EE √† Jakarta EE, comprenant les motivations derri√®re cette transition et l'importance de cette plateforme pour les applications d'entreprise modernes, en particulier celles qui g√®rent des volumes de donn√©es massifs.</li>
                <li>Vous avez mis en place un environnement de d√©veloppement complet et professionnel : le JDK pour ex√©cuter Java, Maven pour g√©rer vos projets et d√©pendances, IntelliJ IDEA comme votre IDE puissant, et WildFly comme votre serveur d'applications Jakarta EE.</li>
                <li>Vous avez r√©ussi √† cr√©er et √† d√©ployer votre toute premi√®re application web Jakarta EE, une √©tape fondamentale qui valide votre environnement et votre compr√©hension des bases du d√©ploiement.</li>
                <li>Nous avons introduit les concepts cl√©s de l'architecture multi-tiers (couches pr√©sentation, m√©tier, persistance, int√©gration) et les sp√©cifications Jakarta EE qui les supportent.</li>
                <li>Nous avons eu un premier aper√ßu de CDI (Contexts and Dependency Injection), un m√©canisme puissant qui simplifiera grandement la modularit√© et la testabilit√© de vos futures applications.</li>
            </ul>

            <h3>Discussion et Questions / R√©ponses (10 min) :</h3>
            <p>C'est le moment d'√©changer et de clarifier les points qui pourraient encore vous sembler flous. N'h√©sitez pas √† poser toutes vos questions !</p>
            <ul>
                <li><strong>Question ouverte :</strong> Quelles ont √©t√© les principales difficult√©s que vous avez rencontr√©es lors de l'installation et de la configuration de l'environnement ? (Partagez vos astuces si vous en avez trouv√© !)</li>
                <li><strong>Question :</strong> Comment percevez-vous la diff√©rence entre un simple serveur web (comme Apache HTTP Server, qui sert des fichiers HTML statiques) et un serveur d'applications comme WildFly ? Pourquoi WildFly est-il n√©cessaire pour nos applications Jakarta EE ?
                    <p><strong>R√©ponse attendue :</strong> Un serveur web sert principalement des contenus statiques et g√®re les requ√™tes HTTP de base. Un serveur d'applications comme WildFly va bien au-del√† : il fournit un environnement d'ex√©cution complet pour les composants Java (Servlets, EJB, etc.), g√®re le cycle de vie de ces composants, et offre des services d'infrastructure essentiels comme la gestion des transactions, les pools de connexions √† la base de donn√©es, la s√©curit√©, et la messagerie. Il est n√©cessaire car nos applications Jakarta EE s'appuient sur ces services et sur le conteneur pour fonctionner correctement.</p>
                </li>
                <li><strong>Question :</strong> Pourquoi est-il important de comprendre le cycle de vie des composants (comme les Servlets ou les beans CDI avec leurs scopes) ?
                    <p><strong>R√©ponse attendue :</strong> Comprendre le cycle de vie est crucial pour g√©rer correctement les ressources et le comportement de votre application. Par exemple, savoir quand une Servlet est initialis√©e (m√©thode <code>init()</code>) ou d√©truite (m√©thode <code>destroy()</code>) permet d'allouer ou de lib√©rer des ressources de mani√®re appropri√©e. Pour les beans CDI, comprendre les scopes (<code>@RequestScoped</code>, <code>@ApplicationScoped</code>, etc.) est vital pour savoir si une instance est partag√©e ou unique, ce qui impacte la gestion de l'√©tat et la performance de l'application, surtout dans un contexte multi-utilisateur ou Big Data.</p>
                </li>
            </ul>

            <h3>Pr√©paration pour la S√©ance Suivante (10 min) :</h3>
            <p>La prochaine s√©ance s'appuiera directement sur les bases √©tablies aujourd'hui. Nous allons plonger plus profond√©ment dans CDI et explorer des patterns architecturaux essentiels.</p>
            <ul>
                <li><strong>S√©ance 2 : CDI et Patterns Architecturaux pour la Scalabilit√©.</strong> Nous allons :
                    <ul>
                        <li>Approfondir les concepts de CDI (qualifiers, producers, interceptors).</li>
                        <li>Introduire et appliquer des patterns de conception fondamentaux comme MVC (Model-View-Controller), DAO (Data Access Object) et DTO (Data Transfer Object).</li>
                        <li>Commencer √† concevoir des applications modulaires et scalables.</li>
                    </ul>
                </li>
                <li><strong>T√¢che √† faire avant la prochaine s√©ance :</strong>
                    <ul>
                        <li><strong>Assurez-vous que votre environnement de d√©veloppement est stable et fonctionnel.</strong> Si vous avez encore des probl√®mes avec le JDK, Maven, IntelliJ ou WildFly, essayez de les r√©soudre ou pr√©parez vos questions pour le d√©but de la prochaine s√©ance.</li>
                        <li><strong>Revoyez les concepts de CDI</strong> introduits aujourd'hui, en particulier les annotations <code>@Inject</code> et les diff√©rents scopes (<code>@RequestScoped</code>, <code>@ApplicationScoped</code>).</li>
                        <li><strong>(Optionnel mais fortement recommand√©) Familiarisez-vous avec les bases des patterns MVC, DAO, DTO.</strong> Une recherche rapide sur Google ou une lecture sur OpenClassrooms vous donnera une premi√®re id√©e de ces concepts qui seront centraux la semaine prochaine.</li>
                    </ul>
                </li>
            </ul>

            <h3>Ressources Suppl√©mentaires pour Approfondissement :</h3>
            <p>Pour ceux qui souhaitent aller plus loin ou revoir certains points √† leur rythme :</p>
            <ul>
                <li><strong>Jakarta EE Official Website :</strong> <a href="https://jakarta.ee/" target="_blank">https://jakarta.ee/</a> - La source officielle pour toutes les sp√©cifications et les derni√®res nouvelles.</li>
                <li><strong>WildFly Documentation :</strong> <a href="https://docs.wildfly.org/" target="_blank">https://docs.wildfly.org/</a> - Documentation compl√®te sur l'installation, la configuration et l'utilisation de WildFly.</li>
                <li><strong>IntelliJ IDEA Documentation :</strong> <a href="https://www.jetbrains.com/help/idea/" target="_blank">https://www.jetbrains.com/help/idea/</a> - Guide d√©taill√© pour tirer le meilleur parti de votre IDE.</li>
                <li><strong>OpenClassrooms - D√©veloppez une application web Java avec Spring Boot :</strong> <a href="https://openclassrooms.com/fr/courses/7170006-developpez-une-application-web-java-avec-spring-boot" target="_blank">https://openclassrooms.com/fr/courses/7170006-developpez-une-application-web-java-avec-spring-boot</a> - Bien que ce cours soit sur Spring Boot, les bases du d√©veloppement web Java (Servlets, JSP, MVC) y sont tr√®s bien expliqu√©es et sont transf√©rables √† Jakarta EE.</li>
                <li><strong>Baeldung - Introduction to CDI :</strong> <a href="https://www.baeldung.com/cdi-tutorial" target="_blank">https://www.baeldung.com/cdi-tutorial</a> - Un excellent tutoriel pour approfondir CDI avec des exemples de code.</li>
            </ul>
        </section>

        <div class="footer">
            <p>&copy; 2025 Module Java JEE pour Ing√©nierie Big Data - 3√®me Ann√©e Cybers√©curit√©. Pr Ahmed AMAMOU. Tous droits r√©serv√©s.</p>
        </div>
    </div>
</body>
</html>
